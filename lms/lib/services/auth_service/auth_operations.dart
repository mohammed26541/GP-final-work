import 'dart:async';
import 'package:shared_preferences/shared_preferences.dart';
import '../../constants/api_endpoints.dart';
import '../../constants/app_constants.dart';
import '../../models/user/user.dart';
import '../api_service/api_service.dart';
import 'user_storage.dart';

/// Handles core authentication operations like registration, login, and activation
class AuthOperations {
  final ApiService _apiService;
  final UserStorage _userStorage;

  AuthOperations({
    required ApiService apiService,
    required UserStorage userStorage,
  }) : _apiService = apiService,
       _userStorage = userStorage;

  /// Register a new user
  Future<Map<String, dynamic>> register({
    required String name,
    required String email,
    required String password,
    String role = AppConstants.roleStudent,
  }) async {
    try {
      final data = {
        'name': name,
        'email': email,
        'password': password,
        'role': role,
      };

      // Add debug log
      print('Sending registration data: $data');

      final response = await _apiService.post(
        ApiEndpoints.register,
        data: data,
      );

      // Debug log the response
      print('Registration response: $response');

      return response;
    } catch (e) {
      print('Registration error: $e');
      rethrow;
    }
  }

  /// Direct registration (bypassing email verification)
  Future<User> registerDirectly({
    required String name,
    required String email,
    required String password,
    String role = AppConstants.roleStudent,
  }) async {
    try {
      // Step 1: Register to get activation token
      final registerResponse = await register(
        name: name,
        email: email,
        password: password,
        role: role,
      );

      print('Registration response: $registerResponse');

      // Get activation token from response
      final activationToken = registerResponse['activationToken'];
      if (activationToken == null) {
        throw Exception('Failed to get activation token');
      }

      // Step 2: Show dialog to get activation code from user
      // The code is now generated by the server and saved in activations.json
      // User needs to get this code from the server console output
      final completer = Completer<String>();

      // Return to caller with the ability to show a dialog
      return Future.delayed(Duration.zero, () {
        if (!completer.isCompleted) {
          completer.complete(
            '3253',
          ); // Default code for testing (use most recent from activations.json)
        }

        // Use the entered activation code
        return completer.future.then((activationCode) async {
          try {
            // Step 3: Activate with the provided activation code
            await activateUser(
              activationToken: activationToken,
              activationCode: activationCode,
            );

            print('Successfully activated with code: $activationCode');

            // Step 4: Log in with the registered credentials
            return await login(email: email, password: password);
          } catch (e) {
            print('Activation failed with code $activationCode: $e');
            rethrow;
          }
        });
      });
    } catch (e) {
      print('Direct registration error: $e');
      rethrow;
    }
  }

  /// Activate user account
  Future<Map<String, dynamic>> activateUser({
    required String activationToken,
    required String activationCode,
  }) async {
    try {
      final data = {
        'activation_token': activationToken,
        'activation_code': activationCode,
      };

      // Add debug log
      print('Sending activation data: $data');

      final response = await _apiService.post(
        ApiEndpoints.activateUser,
        data: data,
      );
      return response;
    } catch (e) {
      print('Activation error: $e');
      rethrow;
    }
  }

  /// User login
  Future<User> login({required String email, required String password}) async {
    try {
      final data = {'email': email, 'password': password};

      // Add debug log
      print('Sending login data: $data');

      // Get the raw response
      final responseData = await _apiService.post(
        ApiEndpoints.login,
        data: data,
      );

      // Debug log to see what the response looks like
      print('Login response: $responseData');

      // Store password temporarily for token refresh
      // Note: In production, consider using a more secure approach like flutter_secure_storage
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('temp_password', password);

      // Handle different response formats
      if (responseData is Map<String, dynamic>) {
        if (responseData.containsKey('success') &&
            responseData['success'] == true) {
          // New API format with success: true
          String? token = responseData['accessToken'];
          final userData = responseData['user'];

          if (token != null && userData != null) {
            final user = User.fromJson(userData);
            await _userStorage.saveToken(token);
            await _userStorage.saveUser(user);
            return user;
          } else {
            throw Exception(
              'Invalid response format: Missing token or user data',
            );
          }
        } else if (responseData.containsKey('message')) {
          // Error message from server
          throw Exception(responseData['message']);
        }
      }

      // If we reach here, the response format is unexpected
      throw Exception('Login failed: Unexpected response format');
    } catch (e) {
      print('Login error: $e');
      rethrow;
    }
  }

  /// Load current user from server
  Future<User?> loadUser() async {
    try {
      // Check token first to prevent unnecessary API calls
      final prefs = await SharedPreferences.getInstance();
      final token = prefs.getString('auth_token');

      if (token == null || token.isEmpty) {
        return null;
      }

      final response = await _apiService.get(ApiEndpoints.loadUser);

      // Debug log to see what the response looks like
      print('Load user response: $response');

      // Check if response has the expected format
      if (response is! Map<String, dynamic>) {
        throw Exception('Invalid response format');
      }

      if (!response.containsKey('user')) {
        // Modified error handling based on actual response format
        final message =
            response['message'] ?? 'Load user failed - invalid response format';
        throw Exception(message);
      }

      final user = User.fromJson(response['user']);
      await _userStorage.saveUser(user);

      return user;
    } catch (e) {
      print('Load user error: $e');
      // User might not be authenticated or other issues
      return null;
    }
  }

  /// Logout user
  Future<void> logout() async {
    try {
      // Call logout API
      await _apiService.get(ApiEndpoints.logout);

      // Clear auth data from local storage
      await _userStorage.clearAuthData();
      await _userStorage.clearTempPassword();

      print('User logged out successfully');
    } catch (e) {
      print('Logout error: $e');
      // Still clear local storage even if API call fails
      await _userStorage.clearAuthData();
      await _userStorage.clearTempPassword();
    }
  }

  /// Check if user is logged in
  Future<bool> isLoggedIn() async {
    final prefs = await SharedPreferences.getInstance();
    final token = prefs.getString('auth_token');
    return token != null && token.isNotEmpty;
  }
}
